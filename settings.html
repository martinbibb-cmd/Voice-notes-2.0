<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Voice Notes 2.0 ‚Äì Settings</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --card: #ffffff;
      --border: #d4dbe5;
      --accent: #667eea;
      --accent-soft: #764ba2;
      --muted: #64748b;
      --danger: #b91c1c;
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
      color: #e2e8f0;
      min-height: 100vh;
      padding: 16px;
      line-height: 1.6;
    }
    header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 16px;
    }
    header h1 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
    header span {
      font-size: .75rem;
      color: #94a3b8;
    }
    a.back-link {
      margin-left: auto;
      font-size: .8rem;
      color: #7dd3fc;
      text-decoration: none;
    }
    a.back-link:hover {
      text-decoration: underline;
    }
    main {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 14px;
    }
    @media (max-width: 900px) {
      main {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .card {
      background: var(--card);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: 12px 14px 14px;
      color: #0f172a;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .card-header {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }
    .card-header h2 {
      margin: 0;
      font-size: .9rem;
      text-transform: uppercase;
      letter-spacing: .05em;
    }
    .card-header span {
      font-size: .7rem;
      color: var(--muted);
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 4px;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 5px 12px 5px;
      font-size: .7rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: var(--accent);
      color: white;
      white-space: nowrap;
    }
    button.secondary {
      background: rgba(148,163,184,.16);
      color: #0f172a;
    }
    button.danger {
      background: var(--danger);
      color: white;
    }
    button.small {
      padding: 3px 8px;
      font-size: .65rem;
      font-weight: 500;
    }
    button:disabled {
      opacity: .55;
      cursor: default;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: .65rem;
      border-radius: 999px;
      padding: 3px 8px;
      background: #e2e8f0;
      color: #0f172a;
    }
    .pill.small {
      font-size: .6rem;
    }
    .pill-tag {
      background: #ecfeff;
      border: 1px solid #e0f2fe;
      border-radius: 999px;
      padding: 2px 7px;
      font-size: .6rem;
      color: #0f172a;
    }
    .rows {
      border-radius: 12px;
      border: 1px solid #e2e8f0;
      max-height: 60vh;
      overflow: auto;
    }
    .row {
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) minmax(0, 2fr) auto;
      gap: 6px;
      padding: 6px 8px;
      align-items: flex-start;
      border-bottom: 1px solid #e2e8f0;
    }
    .row:last-child {
      border-bottom: none;
    }
    .row span.order {
      font-size: .65rem;
      color: var(--muted);
      min-width: 2rem;
    }
    .row input[type="text"] {
      width: 100%;
      font-size: .7rem;
      padding: 3px 5px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
    }
    .row textarea {
      width: 100%;
      font-size: .7rem;
      padding: 3px 5px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
      resize: vertical;
      min-height: 38px;
    }
    .row-controls {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .checklist-rows {
      border-radius: 12px;
      border: 1px solid #e2e8f0;
      max-height: 60vh;
      overflow: auto;
    }
    .checklist-row {
      display: grid;
      grid-template-columns: auto minmax(0, 0.9fr) minmax(0, 1fr) minmax(0, 1.4fr) minmax(0, 2fr) auto;
      gap: 4px;
      padding: 6px 8px;
      align-items: flex-start;
      border-bottom: 1px solid #e2e8f0;
    }
    .checklist-row:last-child {
      border-bottom: none;
    }
    .checklist-row span.order {
      font-size: .65rem;
      color: var(--muted);
      min-width: 1.5rem;
    }
    .checklist-row input[type="text"] {
      width: 100%;
      font-size: .65rem;
      padding: 3px 4px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
    }
    .status {
      font-size: .65rem;
      color: var(--muted);
      margin-top: 4px;
    }
    .status strong {
      color: var(--accent);
    }
    .status.error strong {
      color: var(--danger);
    }
    .hint {
      font-size: .65rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <header>
    <h1>Voice Notes 2.0 Settings</h1>
    <span>Survey sections & checklist configuration</span>
    <button id="forceReloadBtn" class="danger">‚ö† Force reload / reset app data</button>
    <a href="index.html" class="back-link">‚Üê Back to app</a>
  </header>

  <main>
    <!-- AI Provider Settings -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>AI Provider Settings</h2>
        <span>Configure worker URL and AI providers for text analysis</span>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
        <div>
          <label style="display: block; font-size: 0.75rem; font-weight: 600; margin-bottom: 6px;">
            Worker URL
          </label>
          <input type="text" id="workerUrl" 
            placeholder="https://depot-voice-notes.martinbibb.workers.dev"
            style="width: 100%; padding: 8px 12px; border: 1px solid #cbd5e1; border-radius: 8px; font-size: 0.8rem;">
        </div>
        <div>
          <label style="display: block; font-size: 0.75rem; font-weight: 600; margin-bottom: 6px;">
            Preferred AI Provider
          </label>
          <select id="preferredProvider" 
            style="width: 100%; padding: 8px 12px; border: 1px solid #cbd5e1; border-radius: 8px; font-size: 0.8rem;">
            <option value="openai">OpenAI (GPT-4)</option>
            <option value="anthropic">Anthropic (Claude)</option>
            <option value="together">Together AI (Llama)</option>
          </select>
        </div>
      </div>

      <div style="margin-top: 12px;">
        <label style="display: block; font-size: 0.75rem; font-weight: 600; margin-bottom: 6px;">
          Request Timeout (seconds)
        </label>
        <input type="number" id="requestTimeout" min="5" max="120" value="30"
          style="width: 120px; padding: 8px 12px; border: 1px solid #cbd5e1; border-radius: 8px; font-size: 0.8rem;">
      </div>

      <div class="toolbar" style="margin-top: 12px;">
        <button id="saveApiSettingsBtn">Save API Settings</button>
        <button id="testConnectionBtn" class="secondary">Test Connection</button>
        <span id="connectionStatus" style="font-size: 0.7rem; color: var(--muted); margin-left: 8px;"></span>
      </div>

      <p class="hint">
        The worker provides secure access to AI APIs. Configure the worker URL to point to your Cloudflare Worker deployment.
        API keys are stored securely in the worker's environment variables.
      </p>

      <div id="providerStatus" style="display: none; margin-top: 12px; padding: 12px; background: #f8fafc; border-radius: 8px; font-size: 0.75rem;">
        <strong>Provider Status:</strong>
        <div id="providerStatusDetails" style="margin-top: 8px;"></div>
      </div>
    </section>

    <!-- Export Format Preferences -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>Export Format</h2>
        <span>Choose default file format for exports</span>
      </div>
      <div style="display: flex; gap: 12px; align-items: center;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="radio" name="exportFormat" value="json" id="formatJSON" checked>
          <span style="font-size: 0.75rem; font-weight: 600;">JSON (default)</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="radio" name="exportFormat" value="csv" id="formatCSV">
          <span style="font-size: 0.75rem; font-weight: 600;">CSV (Comma-Separated Values)</span>
        </label>
      </div>
      <p class="hint">
        This setting controls the format used when exporting survey notes, transcripts, and recommendations.
        JSON exports include all data in a structured format, while CSV exports are optimized for spreadsheet applications.
      </p>
    </section>

    <!-- LEFT: Survey section schema editor -->
    <section class="card">
      <div class="card-header">
        <h2>Survey Sections</h2>
        <span>Edit the section list & order</span>
        <span class="pill small" id="sections-count-pill">0 sections</span>
      </div>

      <div class="toolbar">
        <button id="sections-add-btn">+ Add section</button>
        <button id="sections-save-btn" class="secondary">Save to browser</button>
        <button id="sections-export-btn" class="secondary">Export JSON</button>
        <button id="sections-import-btn" class="secondary">Import JSON</button>
      </div>
      <p class="hint">
        These control the section headings in the voice notes recording. The sections organize your survey workflow.
        <strong>Names & order are defined here</strong>. Changes take effect on next app load.
      </p>

      <div class="rows" id="sections-rows"></div>

      <p class="status" id="sections-status">Loading sections‚Ä¶</p>
      <input type="file" id="sections-import-input" accept="application/json" style="display:none;">
    </section>

    <!-- RIGHT: Survey checklist editor -->
    <section class="card">
      <div class="card-header">
        <h2>Survey Checklist</h2>
        <span>Groups, IDs & hints</span>
        <span class="pill small" id="checklist-count-pill">0 items</span>
      </div>

      <div class="toolbar">
        <button id="checklist-add-btn">+ Add item</button>
        <button id="checklist-save-btn" class="secondary">Save to browser</button>
        <button id="checklist-export-btn" class="secondary">Export JSON</button>
        <button id="checklist-import-btn" class="secondary">Import JSON</button>
      </div>
      <p class="hint">
        Each item has a stable <strong>ID</strong>, a <strong>group</strong> label, an optional
        <strong>section</strong> link, plus a visible label and hint for guidance during surveys.
      </p>

      <div class="checklist-rows" id="checklist-rows"></div>

      <p class="status" id="checklist-status">Loading checklist‚Ä¶</p>
      <input type="file" id="checklist-import-input" accept="application/json" style="display:none;">
    </section>
  </main>

  <script>
    // Storage keys for Voice Notes 2.0
    const SECTION_STORAGE_KEY = "voiceNotes2.sectionSchema";
    const CHECKLIST_STORAGE_KEY = "voiceNotes2.checklistConfig";
    const AUTOSAVE_KEY = "voiceNotes2_autosave";
    const EXPORT_FORMAT_KEY = "voiceNotes2.exportFormat";

    // --- Helpers ---
    function readJSONSafe(key) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (_) {
        return null;
      }
    }

    function clearStoredAppData() {
      const keys = new Set([
        SECTION_STORAGE_KEY,
        CHECKLIST_STORAGE_KEY,
        AUTOSAVE_KEY,
        EXPORT_FORMAT_KEY
      ]);

      try {
        for (let i = 0; i < localStorage.length; i += 1) {
          const key = localStorage.key(i);
          if (!key) continue;
          const lower = key.toLowerCase();
          if (lower.includes("voicenotes2") || lower.includes("voice-notes")) {
            keys.add(key);
          }
        }
      } catch (err) {
        console.warn("Could not enumerate localStorage keys during reset", err);
      }

      keys.forEach((key) => {
        try {
          localStorage.removeItem(key);
        } catch (err) {
          console.warn("Failed to remove localStorage key", key, err);
        }
      });

      try {
        sessionStorage.clear();
      } catch (err) {
        console.warn("Session storage could not be cleared", err);
      }
    }

    function sanitiseSectionSchema(input) {
      const asArray = (value) => {
        if (!value) return [];
        if (Array.isArray(value)) return value;
        if (value && typeof value === "object" && Array.isArray(value.sections)) {
          return value.sections;
        }
        return [];
      };

      const rawEntries = asArray(input);
      const prepared = [];
      rawEntries.forEach((entry, idx) => {
        if (!entry) return;
        const rawName = entry.name ?? entry.section ?? entry.title ?? entry.heading;
        const name = typeof rawName === "string" ? rawName.trim() : "";
        if (!name) return;
        const rawDescription = entry.description ?? entry.hint ?? "";
        const description = typeof rawDescription === "string"
          ? rawDescription.trim()
          : String(rawDescription || "").trim();
        const order = typeof entry.order === "number" ? entry.order : idx + 1;
        prepared.push({ name, description, order, idx });
      });

      prepared.sort((a, b) => {
        const aHasOrder = typeof a.order === "number";
        const bHasOrder = typeof b.order === "number";
        if (aHasOrder && bHasOrder && a.order !== b.order) {
          return a.order - b.order;
        }
        if (aHasOrder && !bHasOrder) return -1;
        if (!aHasOrder && bHasOrder) return 1;
        return a.idx - b.idx;
      });

      const unique = [];
      const seen = new Set();
      prepared.forEach((entry) => {
        if (seen.has(entry.name)) return;
        seen.add(entry.name);
        unique.push({
          name: entry.name,
          description: entry.description || "",
          order: entry.order
        });
      });

      const final = unique.map((entry, idx) => ({
        name: entry.name,
        description: entry.description || "",
        order: idx + 1
      }));

      return final;
    }

    function sanitiseChecklistConfig(value) {
      const asArray = (input) => {
        if (!input) return [];
        if (Array.isArray(input)) return input;
        if (input && typeof input === "object" && Array.isArray(input.items)) {
          return input.items;
        }
        return [];
      };

      const entries = asArray(value);
      const seen = new Set();
      const cleaned = [];

      entries.forEach((item) => {
        if (!item) return;
        const id = item.id != null ? String(item.id).trim() : "";
        const label = item.label != null ? String(item.label).trim() : "";
        if (!id || !label || seen.has(id)) return;
        seen.add(id);
        cleaned.push({
          id,
          group: (item.group || item.category || "Checklist").trim(),
          section: (item.section || item.sectionName || item.depotSection || "").trim(),
          label,
          hint: (item.hint || item.description || "").trim()
        });
      });

      return cleaned;
    }

    // Default sections for Voice Notes 2.0
    const defaultSections = [
      { name: "Customer Information", description: "Customer name, contact details, property address", order: 1 },
      { name: "Site Survey", description: "Property condition, access, existing system observations", order: 2 },
      { name: "System Details", description: "Current heating system specifications and condition", order: 3 },
      { name: "Measurements", description: "Room dimensions, radiator sizes, pipe runs", order: 4 },
      { name: "Customer Requirements", description: "Customer needs, preferences, budget discussions", order: 5 },
      { name: "Safety Notes", description: "Safety concerns, asbestos, access restrictions", order: 6 },
      { name: "Recommendations", description: "Suggested solutions and system options", order: 7 },
      { name: "Next Steps", description: "Follow-up actions, quotation timeline", order: 8 }
    ];

    // Default checklist for Voice Notes 2.0
    const defaultChecklist = [
      { id: "customer_contact_verified", group: "Customer Info", section: "Customer Information", label: "Customer contact details verified", hint: "Name, phone, email, address" },
      { id: "property_type_recorded", group: "Property", section: "Site Survey", label: "Property type and size recorded", hint: "Flat, terraced, semi-detached, detached" },
      { id: "current_system_documented", group: "System", section: "System Details", label: "Current system type documented", hint: "Combi, system, regular boiler, heat pump" },
      { id: "boiler_age_condition", group: "System", section: "System Details", label: "Boiler age and condition noted", hint: "Approximate age, visible condition, fault codes" },
      { id: "room_measurements", group: "Measurements", section: "Measurements", label: "Room measurements taken", hint: "Key rooms, ceiling heights, radiator locations" },
      { id: "radiator_survey", group: "Measurements", section: "Measurements", label: "Radiator survey completed", hint: "Type, size, condition of all radiators" },
      { id: "customer_priorities", group: "Requirements", section: "Customer Requirements", label: "Customer priorities discussed", hint: "Efficiency, comfort, cost, space, smart controls" },
      { id: "budget_discussed", group: "Requirements", section: "Customer Requirements", label: "Budget expectations discussed", hint: "Ballpark figures, finance options" },
      { id: "safety_concerns", group: "Safety", section: "Safety Notes", label: "Safety concerns identified", hint: "Asbestos, access, pets, vulnerable persons" },
      { id: "recommendations_given", group: "Solutions", section: "Recommendations", label: "Recommendations provided", hint: "System types, brands, benefits discussed" },
      { id: "next_steps_agreed", group: "Follow-up", section: "Next Steps", label: "Next steps agreed", hint: "Quotation timeline, decision date" }
    ];

    // --- Section editor state / rendering ---
    const sectionsRowsEl = document.getElementById("sections-rows");
    const sectionsStatusEl = document.getElementById("sections-status");
    const sectionsCountPill = document.getElementById("sections-count-pill");

    let sections = [];

    function renderSections() {
      sectionsRowsEl.innerHTML = "";
      if (!sections.length) {
        sectionsRowsEl.innerHTML = '<div class="row"><span class="order">‚Äì</span><div class="hint" style="grid-column: span 3;">No sections defined yet. Add your first section above.</div></div>';
        sectionsCountPill.textContent = "0 sections";
        return;
      }
      sectionsCountPill.textContent = sections.length + (sections.length === 1 ? " section" : " sections");

      sections.forEach((sec, idx) => {
        const row = document.createElement("div");
        row.className = "row";

        const orderSpan = document.createElement("span");
        orderSpan.className = "order";
        orderSpan.textContent = idx + 1;

        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = sec.name || "";
        nameInput.placeholder = "Section name";
        nameInput.oninput = () => {
          sections[idx].name = nameInput.value.trim();
        };

        const descInput = document.createElement("textarea");
        descInput.value = sec.description || "";
        descInput.placeholder = "Description / hint (optional)";
        descInput.oninput = () => {
          sections[idx].description = descInput.value.trim();
        };

        const controls = document.createElement("div");
        controls.className = "row-controls";

        const upBtn = document.createElement("button");
        upBtn.className = "small secondary";
        upBtn.textContent = "‚ñ≤";
        upBtn.disabled = idx === 0;
        upBtn.onclick = () => {
          if (idx === 0) return;
          const tmp = sections[idx - 1];
          sections[idx - 1] = sections[idx];
          sections[idx] = tmp;
          renderSections();
        };

        const downBtn = document.createElement("button");
        downBtn.className = "small secondary";
        downBtn.textContent = "‚ñº";
        downBtn.disabled = idx === sections.length - 1;
        downBtn.onclick = () => {
          if (idx === sections.length - 1) return;
          const tmp = sections[idx + 1];
          sections[idx + 1] = sections[idx];
          sections[idx] = tmp;
          renderSections();
        };

        const delBtn = document.createElement("button");
        delBtn.className = "small danger";
        delBtn.textContent = "‚úï";
        delBtn.onclick = () => {
          if (!confirm(`Remove section "${sec.name || "Untitled"}"?`)) return;
          sections.splice(idx, 1);
          renderSections();
        };

        controls.appendChild(upBtn);
        controls.appendChild(downBtn);
        controls.appendChild(delBtn);

        row.appendChild(orderSpan);
        row.appendChild(nameInput);
        row.appendChild(descInput);
        row.appendChild(controls);
        sectionsRowsEl.appendChild(row);
      });
    }

    function loadSections() {
      sectionsStatusEl.textContent = "Loading sections‚Ä¶";

      const stored = readJSONSafe(SECTION_STORAGE_KEY);
      const candidate = sanitiseSectionSchema(stored || defaultSections);

      sections = candidate;
      sectionsStatusEl.innerHTML = `Loaded <strong>${sections.length}</strong> sections (${stored ? "from browser storage" : "defaults"}).`;
      renderSections();
    }

    function saveSectionsToLocal() {
      const cleaned = sanitiseSectionSchema(sections);
      const payload = { sections: cleaned };
      localStorage.setItem(SECTION_STORAGE_KEY, JSON.stringify(payload));
      sectionsStatusEl.innerHTML = `Saved <strong>${cleaned.length}</strong> sections to browser. Reload the app to apply changes.`;
    }

    function exportSectionsJSON() {
      const cleaned = sanitiseSectionSchema(sections);
      const payload = { sections: cleaned };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `voicenotes2.sections-${ts}.json`;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      sectionsStatusEl.innerHTML = `Exported <strong>${cleaned.length}</strong> sections as JSON file.`;
    }

    function importSectionsJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          const cleaned = sanitiseSectionSchema(data);
          sections = cleaned;
          localStorage.setItem(SECTION_STORAGE_KEY, JSON.stringify({ sections: cleaned }));
          renderSections();
          sectionsStatusEl.innerHTML = `Imported <strong>${cleaned.length}</strong> sections and saved to browser.`;
        } catch (err) {
          console.error(err);
          sectionsStatusEl.classList.add("error");
          sectionsStatusEl.innerHTML = `<strong>Error:</strong> Could not parse JSON file.`;
        }
      };
      reader.readAsText(file);
    }

    // --- Checklist editor state / rendering ---
    const checklistRowsEl = document.getElementById("checklist-rows");
    const checklistStatusEl = document.getElementById("checklist-status");
    const checklistCountPill = document.getElementById("checklist-count-pill");

    let checklist = [];

    function renderChecklistEditor() {
      checklistRowsEl.innerHTML = "";
      if (!checklist.length) {
        checklistRowsEl.innerHTML = '<div class="checklist-row"><span class="order">‚Äì</span><div class="hint" style="grid-column: span 5;">No checklist items yet. Add your first item above.</div></div>';
        checklistCountPill.textContent = "0 items";
        return;
      }
      checklistCountPill.textContent = checklist.length + (checklist.length === 1 ? " item" : " items");

      checklist.forEach((item, idx) => {
        const row = document.createElement("div");
        row.className = "checklist-row";

        const orderSpan = document.createElement("span");
        orderSpan.className = "order";
        orderSpan.textContent = idx + 1;

        const idInput = document.createElement("input");
        idInput.type = "text";
        idInput.value = item.id || "";
        idInput.placeholder = "ID (stable)";
        idInput.oninput = () => {
          checklist[idx].id = idInput.value.trim();
        };

        const groupInput = document.createElement("input");
        groupInput.type = "text";
        groupInput.value = item.group || "";
        groupInput.placeholder = "Group";
        groupInput.oninput = () => {
          checklist[idx].group = groupInput.value.trim();
        };

        const sectionInput = document.createElement("input");
        sectionInput.type = "text";
        sectionInput.value = item.section || "";
        sectionInput.placeholder = "Section (optional)";
        sectionInput.oninput = () => {
          checklist[idx].section = sectionInput.value.trim();
        };

        const labelInput = document.createElement("input");
        labelInput.type = "text";
        labelInput.value = item.label || "";
        labelInput.placeholder = "Question / label";
        labelInput.oninput = () => {
          checklist[idx].label = labelInput.value.trim();
        };

        const hintInput = document.createElement("input");
        hintInput.type = "text";
        hintInput.value = item.hint || "";
        hintInput.placeholder = "Hint (optional)";
        hintInput.oninput = () => {
          checklist[idx].hint = hintInput.value.trim();
        };

        const controls = document.createElement("div");
        controls.className = "row-controls";

        const upBtn = document.createElement("button");
        upBtn.className = "small secondary";
        upBtn.textContent = "‚ñ≤";
        upBtn.disabled = idx === 0;
        upBtn.onclick = () => {
          if (idx === 0) return;
          const tmp = checklist[idx - 1];
          checklist[idx - 1] = checklist[idx];
          checklist[idx] = tmp;
          renderChecklistEditor();
        };

        const downBtn = document.createElement("button");
        downBtn.className = "small secondary";
        downBtn.textContent = "‚ñº";
        downBtn.disabled = idx === checklist.length - 1;
        downBtn.onclick = () => {
          if (idx === checklist.length - 1) return;
          const tmp = checklist[idx + 1];
          checklist[idx + 1] = checklist[idx];
          checklist[idx] = tmp;
          renderChecklistEditor();
        };

        const delBtn = document.createElement("button");
        delBtn.className = "small danger";
        delBtn.textContent = "‚úï";
        delBtn.onclick = () => {
          if (!confirm(`Remove checklist item "${item.label || item.id || "Untitled"}"?`)) return;
          checklist.splice(idx, 1);
          renderChecklistEditor();
        };

        controls.appendChild(upBtn);
        controls.appendChild(downBtn);
        controls.appendChild(delBtn);

        row.appendChild(orderSpan);
        row.appendChild(idInput);
        row.appendChild(groupInput);
        row.appendChild(sectionInput);
        row.appendChild(labelInput);
        row.appendChild(hintInput);
        row.appendChild(controls);

        checklistRowsEl.appendChild(row);
      });
    }

    function loadChecklist() {
      checklistStatusEl.textContent = "Loading checklist‚Ä¶";

      const stored = sanitiseChecklistConfig(readJSONSafe(CHECKLIST_STORAGE_KEY));
      const candidate = stored.length ? stored : defaultChecklist;

      checklist = candidate;

      const source = stored.length ? "browser storage" : "defaults";
      checklistStatusEl.innerHTML = `Loaded <strong>${checklist.length}</strong> items (${source}).`;
      renderChecklistEditor();
    }

    function saveChecklistToLocal() {
      const cleaned = sanitiseChecklistConfig(checklist);
      const payload = { items: cleaned };
      localStorage.setItem(CHECKLIST_STORAGE_KEY, JSON.stringify(payload));
      checklistStatusEl.innerHTML = `Saved <strong>${cleaned.length}</strong> checklist items to browser.`;
    }

    function exportChecklistJSON() {
      const cleaned = sanitiseChecklistConfig(checklist);
      const payload = { items: cleaned };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `voicenotes2.checklist-${ts}.json`;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      checklistStatusEl.innerHTML = `Exported <strong>${cleaned.length}</strong> checklist items as JSON file.`;
    }

    function importChecklistJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          const cleaned = sanitiseChecklistConfig(data);
          checklist = cleaned;
          localStorage.setItem(CHECKLIST_STORAGE_KEY, JSON.stringify({ items: cleaned }));
          renderChecklistEditor();
          checklistStatusEl.innerHTML = `Imported <strong>${cleaned.length}</strong> checklist items and saved to browser.`;
        } catch (err) {
          console.error(err);
          checklistStatusEl.classList.add("error");
          checklistStatusEl.innerHTML = `<strong>Error:</strong> Could not parse JSON file.`;
        }
      };
      reader.readAsText(file);
    }

    // --- Wire up buttons ---
    const forceReloadBtn = document.getElementById("forceReloadBtn");
    if (forceReloadBtn) {
      forceReloadBtn.addEventListener("click", () => {
        const confirmReset = confirm(
          "‚ö†Ô∏è WARNING: This will delete ALL stored Voice Notes 2.0 data including:\n\n" +
          "‚Ä¢ All saved surveys and transcripts\n" +
          "‚Ä¢ All photos and annotations\n" +
          "‚Ä¢ All recommendations\n" +
          "‚Ä¢ All settings and configurations\n\n" +
          "This action CANNOT be undone!\n\n" +
          "Are you absolutely sure you want to continue?"
        );
        if (!confirmReset) return;

        const doubleCheck = confirm(
          "‚ö†Ô∏è FINAL CONFIRMATION\n\n" +
          "This is your last chance to cancel.\n\n" +
          "Click OK to permanently delete all data and reset the app."
        );
        if (!doubleCheck) return;

        const originalLabel = forceReloadBtn.textContent;
        forceReloadBtn.disabled = true;
        forceReloadBtn.textContent = "Resetting‚Ä¶";
        try {
          clearStoredAppData();
          setTimeout(() => {
            window.location.replace("index.html");
          }, 500);
        } catch (err) {
          console.error("Force reload/reset failed", err);
          alert("Failed to reset stored data. Please try clearing your browser cache manually.");
          forceReloadBtn.disabled = false;
          forceReloadBtn.textContent = originalLabel;
        }
      });
    }

    document.getElementById("sections-add-btn").onclick = () => {
      sections.push({
        name: "",
        description: "",
        order: sections.length + 1
      });
      renderSections();
    };
    document.getElementById("sections-save-btn").onclick = saveSectionsToLocal;
    document.getElementById("sections-export-btn").onclick = exportSectionsJSON;
    document.getElementById("sections-import-btn").onclick = () => {
      document.getElementById("sections-import-input").click();
    };
    document.getElementById("sections-import-input").onchange = (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      importSectionsJSON(file);
      e.target.value = "";
    };

    document.getElementById("checklist-add-btn").onclick = () => {
      checklist.push({
        id: "",
        group: "Checklist",
        section: "",
        label: "",
        hint: ""
      });
      renderChecklistEditor();
    };
    document.getElementById("checklist-save-btn").onclick = saveChecklistToLocal;
    document.getElementById("checklist-export-btn").onclick = exportChecklistJSON;
    document.getElementById("checklist-import-btn").onclick = () => {
      document.getElementById("checklist-import-input").click();
    };
    document.getElementById("checklist-import-input").onchange = (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      importChecklistJSON(file);
      e.target.value = "";
    };

    // --- Export Format Preferences ---
    function loadExportFormat() {
      const format = localStorage.getItem(EXPORT_FORMAT_KEY) || 'json';
      const radioBtn = document.getElementById(format === 'csv' ? 'formatCSV' : 'formatJSON');
      if (radioBtn) radioBtn.checked = true;
    }

    function saveExportFormat(format) {
      localStorage.setItem(EXPORT_FORMAT_KEY, format);
    }

    document.querySelectorAll('input[name="exportFormat"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        saveExportFormat(e.target.value);
      });
    });

    // --- API Settings ---
    const WORKER_SETTINGS_KEY = 'voiceNotes2.workerSettings';

    function loadApiSettings() {
      try {
        const saved = localStorage.getItem(WORKER_SETTINGS_KEY);
        if (saved) {
          const settings = JSON.parse(saved);
          
          const workerUrlInput = document.getElementById('workerUrl');
          const providerSelect = document.getElementById('preferredProvider');
          const timeoutInput = document.getElementById('requestTimeout');
          
          if (workerUrlInput && settings.workerUrl) {
            workerUrlInput.value = settings.workerUrl;
          }
          if (providerSelect && settings.preferredProvider) {
            providerSelect.value = settings.preferredProvider;
          }
          if (timeoutInput && settings.requestTimeout) {
            timeoutInput.value = Math.round(settings.requestTimeout / 1000);
          }
        } else {
          // Set default values
          const workerUrlInput = document.getElementById('workerUrl');
          if (workerUrlInput) {
            workerUrlInput.value = 'https://depot-voice-notes.martinbibb.workers.dev';
          }
        }
      } catch (e) {
        console.warn('Failed to load API settings:', e);
      }
    }

    function saveApiSettings() {
      try {
        const workerUrl = document.getElementById('workerUrl').value.trim();
        const preferredProvider = document.getElementById('preferredProvider').value;
        const requestTimeout = parseInt(document.getElementById('requestTimeout').value) * 1000;

        const settings = {
          workerUrl: workerUrl || 'https://depot-voice-notes.martinbibb.workers.dev',
          preferredProvider: preferredProvider || 'openai',
          requestTimeout: requestTimeout || 30000
        };

        localStorage.setItem(WORKER_SETTINGS_KEY, JSON.stringify(settings));
        return true;
      } catch (e) {
        console.error('Failed to save API settings:', e);
        return false;
      }
    }

    async function testWorkerConnection() {
      const connectionStatus = document.getElementById('connectionStatus');
      const providerStatus = document.getElementById('providerStatus');
      const providerStatusDetails = document.getElementById('providerStatusDetails');

      connectionStatus.textContent = 'Testing connection...';
      connectionStatus.style.color = 'var(--accent)';

      const workerUrl = document.getElementById('workerUrl').value.trim() || 'https://depot-voice-notes.martinbibb.workers.dev';

      try {
        const response = await fetch(`${workerUrl}/health`, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();

        if (data.status === 'ok') {
          connectionStatus.textContent = '‚úÖ Connected successfully!';
          connectionStatus.style.color = '#10b981';

          // Show provider status
          providerStatus.style.display = 'block';
          
          const providers = data.providers || {};
          let statusHtml = '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">';
          
          statusHtml += `<div style="padding: 8px; border-radius: 6px; background: ${providers.openai ? '#d1fae5' : '#fee2e2'};">
            <strong>OpenAI:</strong> ${providers.openai ? '‚úÖ Ready' : '‚ùå Not configured'}
          </div>`;
          
          statusHtml += `<div style="padding: 8px; border-radius: 6px; background: ${providers.anthropic ? '#d1fae5' : '#fee2e2'};">
            <strong>Anthropic:</strong> ${providers.anthropic ? '‚úÖ Ready' : '‚ùå Not configured'}
          </div>`;
          
          statusHtml += `<div style="padding: 8px; border-radius: 6px; background: ${providers.together ? '#d1fae5' : '#fee2e2'};">
            <strong>Together:</strong> ${providers.together ? '‚úÖ Ready' : '‚ùå Not configured'}
          </div>`;
          
          statusHtml += '</div>';
          
          if (data.database) {
            statusHtml += '<div style="margin-top: 8px;">üíæ Database storage: ‚úÖ Available</div>';
          }
          
          providerStatusDetails.innerHTML = statusHtml;
        } else {
          throw new Error(data.error || 'Unknown error');
        }
      } catch (error) {
        connectionStatus.textContent = `‚ùå Connection failed: ${error.message}`;
        connectionStatus.style.color = 'var(--danger)';
        providerStatus.style.display = 'none';
      }
    }

    // Wire up API settings buttons
    const saveApiSettingsBtn = document.getElementById('saveApiSettingsBtn');
    const testConnectionBtn = document.getElementById('testConnectionBtn');

    if (saveApiSettingsBtn) {
      saveApiSettingsBtn.addEventListener('click', () => {
        if (saveApiSettings()) {
          alert('API settings saved successfully!');
        } else {
          alert('Failed to save API settings.');
        }
      });
    }

    if (testConnectionBtn) {
      testConnectionBtn.addEventListener('click', () => {
        testWorkerConnection();
      });
    }

    // --- Boot ---
    (function boot() {
      loadSections();
      loadChecklist();
      loadExportFormat();
      loadApiSettings();
    })();
  </script>
</body>
</html>
